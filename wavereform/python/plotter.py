
from icecube.wavereform import refold_pulses, chi_squared
from icecube.icetray import I3ConditionalModule, I3Module, I3Units
from icecube.dataclasses import I3Waveform, I3RecoPulseSeriesMap
import numpy
import pylab
import itertools
from matplotlib.colors import hsv_to_rgb
from collections import defaultdict

class HoboStatus(object):
	def __init__(self, start, stop, status=I3Waveform.VIRGINAL):
		self.interval = (start, stop)
		self.status = status
	@classmethod
	def fromStatusCompound(cls, stat):
		return cls(stat.interval[0], stat.interval[1], stat.status)
	@classmethod
	def inflate(cls, wf):
		stati = wf.waveform_information
		expanded = []
		j = 0
		i = 0
		while i < len(wf.waveform):
			if j < len(stati) and i < stati[j].interval[0]:
				stat = cls(i, stati[j].interval[0])
				expanded.append(stat)
				i = stati[j].interval[0]
			elif j < len(stati) and i == stati[j].interval[0]:
				expanded.append(cls.fromStatusCompound(stati[j]))
				i = stati[j].interval[1]
				j += 1
			elif j == len(stati):
				stat = cls(i, len(wf.waveform))
				expanded.append(stat)
				break
		return expanded
		
def clip_path(edges, bins, slice_):

	npoints = 2*(slice_.stop-slice_.start+1)
	
	# Starting and stopping spans get one point fewer.
	if (slice_.start == 0 or slice_.stop == len(bins)) and slice_.stop-slice_.start < len(bins):
		npoints -= 1
	
	x = numpy.zeros(npoints, numpy.float)
	y = numpy.zeros(npoints, numpy.float)
		
	if slice_.start == 0 and slice_.stop == len(bins):
		# complete span
		x[0::2], x[1::2] = edges, edges
		y[1:-1:2], y[2::2] = bins, bins
	elif slice_.start == 0:
		# starting span
		x[0:-1:2], x[1::2] = edges[slice_], edges[slice_]
		x[-1] = edges[slice_.stop]
		y[1::2] = bins[slice_]
		y[2::2] = bins[slice_]
	elif slice_.stop == len(bins):
		# ending span
		sl = slice(slice_.start+1, slice_.stop+1)
		x[0] = edges[slice_.start]
		x[1::2], x[2::2] = edges[sl], edges[sl]
		y[0:-1:2] = bins[slice_]
		y[1::2]   = bins[slice_]
	else:
		# interior span
		sl = slice(slice_.start, slice_.stop+1)
		x[::2], x[1::2] = edges[sl], edges[sl]
		y[1:-1:2] = bins[slice_]
		y[2::2] = bins[slice_]
		
		y[0] = bins[slice_.start-1]
		y[-1] = bins[slice_.stop]
	
	return x, y

class ShowPlots(I3Module):
	"""
	Show plots generated by previous instances of WaveformPlotter with
	Block=False.
	"""
	def __init__(self, ctx):
		I3Module.__init__(self, ctx)
		self.AddOutBox("OutBox")

	def Configure(self):
		pass

	def DAQ(self, frame):
		pylab.show()
		self.PushFrame(frame)

class WaveformPlotter(I3ConditionalModule):
	def __init__(self, ctx=None):
		I3ConditionalModule.__init__(self, ctx)
		
		self.AddParameter('Launches', 'Name of DOMLaunches in the frame', None)
		self.AddParameter('Waveforms', 'Name of calibrated waveforms in the frame', 'CalibratedWaveforms')
		self.AddParameter('Errata', 'Time windows in which calibration should be considered fishy', [])
		self.AddParameter('ShowChiSquared', '', True)
		self.AddParameter('Pulses', 'Name of pulses in the frame', 'WavedeformPulses')
		self.AddParameter('Block', 'Stop to display plots at every frame', True)
		self.AddParameter('UseDOMsimulatorTemplates', 'Use pulse shapes from simulation', False)
		
		self.AddOutBox("OutBox")
		
	def Configure(self):
		
		self.launchname = self.GetParameter('Launches')
		self.wfname = self.GetParameter('Waveforms')
		self.errata = self.GetParameter('Errata')
		self.show_chi2 = self.GetParameter('ShowChiSquared')
		self.pulsename = self.GetParameter('Pulses')
		self.block = self.GetParameter('Block')
		self.use_domsimulator_hacks = self.GetParameter('UseDOMsimulatorTemplates')
	
	@staticmethod
	def plot_wf(ax, wf, **kwargs):
		times = wf.time + wf.bin_width*numpy.arange(0, len(wf.waveform)+1)
		trace = numpy.array(wf.waveform)
		kwargs['ls'] = 'steps'
		times /= I3Units.microsecond
		trace /= I3Units.mV
		
		valid = []
		clipped = []
		for stat in HoboStatus.inflate(wf):
			if stat.status == wf.VIRGINAL:
				valid.append(stat.interval)
			else:
				clipped.append(stat.interval)
				
		for rng in valid:
			x, y = clip_path(times, trace, slice(*rng))
			kwargs['ls'] = '-'
			ax.plot(x, y, **kwargs)
			kwargs['label'] = '__nolabel__'
			
		for rng in clipped:
			x, y = clip_path(times, trace, slice(*rng))
			kwargs['ls'] = ':'
			ax.plot(x, y, **kwargs)
	
	@staticmethod
	def plot_pulses(ax, trange, wf, pulses, cal, stat, use_domsimulator_hacks=False, **kwargs):

		times = numpy.arange(trange[0], trange[1], 0.25)
		# shift times by half a digitizer bin so that the plotted
		# points cross through the center of the bin
		half_shift = wf.bin_width/2.
		
		trace = refold_pulses(pulses, wf.digitizer, wf.channel,
		    cal, stat, times, use_domsimulator_hacks)
		
		ax.plot((times-half_shift)/I3Units.microsecond, trace/I3Units.mV, **kwargs)
	
	@staticmethod
	def plot_exclusions(ax, trange, windows, **kwargs):
		import matplotlib.transforms as mtransforms
		from matplotlib.patches import Rectangle
		# Specify x in data coords and y in axis coords
		trans = mtransforms.blended_transform_factory(ax.transData, ax.transAxes)		
		
		for w in windows:
			rect = Rectangle((w.start/I3Units.microsecond, 0), (w.stop-w.start)/I3Units.microsecond, 1,
			    edgecolor=None, alpha=0.3, transform=trans, **kwargs)
			ax.add_patch(rect)
			kwargs.pop('label', None)
	
	@staticmethod
	def get_time_range(wfs):
		tstart, tend = numpy.inf, -numpy.inf
		for wf in wfs:
			if wf.time < tstart:
				tstart = wf.time
			end_time = wf.time + wf.bin_width*len(wf.waveform)
			if end_time > tend:
				tend = end_time
		
		return tstart, tend
		
	def DAQ(self, frame):
		wfname = self.wfname
		pulsename = self.pulsename

		if pulsename in frame:
			pulsemap = I3RecoPulseSeriesMap.from_frame(frame, pulsename)
		else:
			pulsemap = None

		if self.launchname is not None and self.launchname in frame:
			launches = frame[self.launchname]
		else:
			launches = None
		
		calib = frame['I3Calibration']
		status = frame['I3DetectorStatus']
		errata = dict()
		for k in self.errata:
			if k in frame:
				errata[k] = frame[k]
		
		wfsm = frame[wfname]
		for om, wfs in wfsm.items():
			
			cal = calib.dom_cal[om]
			stat = status.dom_status[om]
			
			if pulsemap and om in pulsemap:
				pulses = pulsemap[om]
			else:
				pulses = None
			
			atwds = defaultdict(list)
			fadcs = []
			
			# organize or channels
			for wf in wfs:
				if wf.digitizer is I3Waveform.ATWD:
					atwds[wf.channel].append(wf)
				elif wf.digitizer is I3Waveform.FADC:
					fadcs.append(wf)
			
			fig = pylab.figure(figsize=(8,4))
			fig.subplots_adjust(left=0.1, bottom=0.12, right=0.96, top=0.90)
			ax = pylab.gca()
			
			trange = self.get_time_range(wfs)
			
			colors = itertools.cycle([ 'b', 'r',      'g',      'goldenrod'])
			pcolors = itertools.cycle(['c', 'orange', 'indigo', 'deeppink'])
			pcolors = itertools.cycle(['b', 'r',      'g',      'goldenrod'])
			
			wfs = fadcs
			label = 'FADC'
			color = colors.next()
			for wf in wfs:
				self.plot_wf(ax, wf, color=color, label=label)
				label='__nolabel__'
			
			for channel in range(len(atwds)):
				wfs = atwds[channel]
				label = 'ATWD%d' % channel
				color = colors.next()
				
				for wf in wfs:
					self.plot_wf(ax, wf, color=color, label=label)
					label = '__nolabel__'
			
			if pulses:
				for wfs in [fadcs] + [atwds[i] for i in range(len(atwds))]:
					if len(wfs) == 0:
						continue
					pcolor = pcolors.next()
					if self.show_chi2:
						chi2 = 0; nterms = 0
						for wf in wfs:
							c, n = chi_squared(pulses, wf, cal, stat)
							chi2 += c
							nterms += n
						label = 'chi2 = %.1f' % (chi2/nterms)
					else:
						label = '__nolabel__'
					self.plot_pulses(ax, trange, wfs[0], pulses, cal, stat,
					    use_domsimulator_hacks=self.use_domsimulator_hacks,
					    color=pcolor, label=label)
			
			
			for c, k in zip(('b', 'r'), errata):
				if om in errata[k]:
					windows = errata[k][om]
					self.plot_exclusions(ax, trange, windows, color=c, label=k)
					
			pylab.grid()
			pylab.ylabel('ADC voltage [-mV]')
			pylab.xlabel('Time [microseconds]')
			pylab.legend(prop=dict(size='small'), ncol=2)
			title = ('OM(%d,%d) %s' % (om.string, om.om, wfname))
			if pulses:
				qtot = sum([pulse.charge for pulse in pulses])
				title += ('/%s: %.1f PE' % (pulsename, qtot))
			pylab.title(title, size='small')

		if launches is not None:
			for om in wfsm.keys():
				figure = pylab.figure(figsize=(8,4))
				dls = [dl for dl in launches[om] if dl.lc_bit]
				for i, dl in enumerate(dls):
					ax = pylab.subplot(1,len(dls),i+1)
					pylab.plot(dl.raw_fadc, ls='steps')
					for atwd in dl.raw_atwd:
						if len(atwd) > 0:
							pylab.plot(atwd, ls='steps')
				pylab.title(str(om))
		
		if self.block:	
			pylab.show()

		self.PushFrame(frame)
