/**
 * class: I3MonopolePropagator.cxx
 * (c) 2008 IceCube Collaboration
 * Version $Id: I3MonopolePropagator.cxx 141809 2016-02-13 17:31:29Z anna.obertacke $
 *
 * Date 06 Feb 2008
 * @version $Revision: 141809 $
 * @date $Date: 2016-02-13 11:31:29 -0600 (Sa, 13. Feb 2016) $
 * @author Brian Christy <bchristy@icecube.umd.edu>
 * @author Alex Olivas <olivas@icecube.umd.edu>
 *
 * @brief A module to convert Monopoles into a chain of propagated
 * @brief particles through the ice
 *
 */

#include "monopole-generator/I3MonopolePropagator.h"
#include "I3MonopoleRelativisticUtils.h"
#include "I3MonopoleSlowUtils.h"


#include "icetray/I3Frame.h"
#include "dataclasses/I3Double.h"
#include "dataclasses/physics/I3Particle.h"
#include "dataclasses/physics/I3MCTree.h"
#include "dataclasses/physics/I3MCTreeUtils.h"


I3_MODULE(I3MonopolePropagator);

I3MonopolePropagator::I3MonopolePropagator(const I3Context &ctx) :
        I3Module(ctx),
        inputTreeName_("I3MCTree"),
        outputTreeName_("I3MCTree"),
        infoName_("MPInfoDict"),
        betaThreshold_(0.09),

        // fast
        calcEn_(true),
        calcDen_(true),
        stepSize_(NAN),
        checkParticle_(true),
        speedmin_(0.09 * I3Constants::c),
        maxlength_(10.0 * I3Units::m),
        minlength_(0.001 * I3Units::m),
        maxdistfromcenter_(1300 * I3Units::m),
        profiling_(false),

        // slow
        meanFreePath_(NAN),
        useCorrectDecay_(false),
        scaleEnergy_(false),
        energyScaleFactor_(1.0) {
    log_debug("Constructor I3MonopolePropagator");

    AddParameter("InputTreeName", "Name of the `I3MCTree` containing the monopole generated by the monopole generator.", inputTreeName_);
    AddParameter("OutputTreeName", "Name of the `I3MCTree` to write the monopole into after propagation.", outputTreeName_);
    AddParameter("InfoName", "Name of the monopole info dictionary, containing all necessary information about the generation parameters.", infoName_);
    AddParameter("BetaThreshold", "Threshold that determines whether the monopole propagator handles the monopole particle as slow (non-relativistic) or fast (relativistic) particle. This determines the interaction types the propagator will consider. See: `README.md`", betaThreshold_);

    // Parameters for relativistic (fast) monopole particles:
    AddParameter("CalculateEnergy", "If set to `true`, the energy loss of the monopole particles due to ionization effects is calculated during the propagation. If set to `false`, the monopole-particle energy and velocity are not decreasing during propagation.", calcEn_);
    AddParameter("MaxDistanceFromCenter", "How far beyond the detector to propagate the monopole. If the start of the monopole is further from the detector than this value, the propagator will IGNORE the parameter and propagate until it reaches the same distance away on far side of detector. Example: `800 * I3Units::m`", maxdistfromcenter_);
    AddParameter("Profiling", "If `true`, adds a profile (type `I3VectorDouble`) of the monopole speed for each track segment to the frame.", profiling_);
    AddParameter("SpeedMin", "The speed at which the propagator should stop propagating. The value should not be set below around 0.1c if one is using `CalculateEnergy`, since the ionization formula assumes it above this range. If you use a lower speed min, please make sure you turn off `CalculateEnergy` and treat this as a track segmentor only. Example: `0.09 * I3Constants::c`", speedmin_);
    AddParameter("StepSize", "Length of monopole track segments. If set this will override `MinLength` and `MaxLength`. Otherwise, `MinLength` and `MaxLength` are used to set the lower and upper bounds on the track segment lengths. Example: `1 * I3Units::m`", stepSize_);
    AddParameter("MinLength", "Assuming `StepSize` is `NaN`, this represents the smallest segment the propagator will generate. Example: `0.001 * I3Units::m`", minlength_);
    AddParameter("MaxLength", "Assuming stepsize is `NaN`, this represents the largest segment the propagator will generate. Example: `10 * I3Units::m`", maxlength_);


    // Parameters for non-relativistic (slow) monopole particles:
    AddParameter("MeanFreePath", "Mean free path (lambda) between catalyzed proton decays. Example: `1 * I3Units::m`", meanFreePath_);
    AddParameter("ScaleEnergy", "Whether to set the mean free path (lambda) to 1 meter and scale up the energy by 1/lambda. The overall light output stays comparable, while the number of secondary particles in the `I3MCTree` is reduced. This saves computing resources especially for short mean free paths.", scaleEnergy_);
    AddParameter("UseCorrectDecay", "  Whether to simulate back-to-back positrons (460 MeV) and neutral pions (480 MeV) instead of just one positron. The overall light output is similar, but correct decay has twice as much secondary particles in the `I3MCTree`. This option cannot be used together with `ScaleEnergy` or `EnergyScaleFactor`, since the energies are hard coded.",
                 useCorrectDecay_);
    AddParameter("EnergyScaleFactor",
                 "Scale down the cascade energy in order to test the influence of other decay channels.",
                 energyScaleFactor_);


    AddOutBox("OutBox");
}

I3MonopolePropagator::~I3MonopolePropagator() { }

void I3MonopolePropagator::Configure() {
    log_debug("Configure I3MonopolePropagator");

    GetParameter("InputTreeName", inputTreeName_);
    GetParameter("OutputTreeName", outputTreeName_);
    GetParameter("InfoName", infoName_);
    GetParameter("BetaThreshold", betaThreshold_);
    // fast
    GetParameter("CalculateEnergy", calcEn_);
    //GetParameter("CalculateDensityCorrection",calcDen_);
    GetParameter("StepSize", stepSize_);
    //GetParameter("IncludeErrorChecking",checkParticle_);
    GetParameter("SpeedMin", speedmin_);
    GetParameter("MaxLength", maxlength_);
    GetParameter("MinLength", minlength_);
    GetParameter("MaxDistanceFromCenter", maxdistfromcenter_);
    // slow
    GetParameter("MeanFreePath", meanFreePath_);
    GetParameter("ScaleEnergy", scaleEnergy_);
    GetParameter("UseCorrectDecay", useCorrectDecay_);
    GetParameter("EnergyScaleFactor", energyScaleFactor_);



    /**
     * Check that input parameters are sane
     */

    // fast
    if ((calcDen_ == true) && (calcEn_) == false) {
        log_warn(
                "Cannot calculate density correction (default true) if calculate energy loss is false; setting energy calculation to true");
        calcEn_ = true;
    }
    if (minlength_ > maxlength_) {
        log_fatal("Oops, MaxLength<MinLength.  Did you switch them?");
    }
    if ((speedmin_ < 0.1 * I3Constants::c) && (calcEn_ == true)) {
        log_warn(
                "Propagate method will continue until monopoles reach a speed of %f. However, shell corrections (amongst other things), ignored in this ionization formula, might be becoming important. If you just want to use this as a track segmenter, set CalculateEnergy to false. Othewise, make sure you know what you're doing",
                speedmin_);
    }

    // slow
    if (meanFreePath_ <= 0.0) {
        log_fatal("Mean Free Path must be a positive number");
    }

    if (energyScaleFactor_ > 1.0 || energyScaleFactor_ <= 0) {
        log_fatal(
                "The vaild range for the energy scale factor is between > 0 and <= 1.0, since then the cascade energy cannot be zero or negative and not be greater than the proton mass (rest energy). ");
    }
    if (useCorrectDecay_ && scaleEnergy_) {
        log_fatal(
                "Correct decay and scale energy cannot be used together, since correct decay depends on a hard coded energy.");
    }
    if (useCorrectDecay_ && energyScaleFactor_ != 1.0) {
        log_fatal(
                "Correct decay and energy scale factor cannot be used together, since correct decay depends on a hard coded energy.");
    }

    deltaEnergy_ = 0.94 * I3Units::GeV * energyScaleFactor_;

    if (scaleEnergy_) {
        //meanFreePath could be NAN here. Why is this not a problem?
        //wouldn't this set deltaEnergy to NAN as well? //FHL
        if (meanFreePath_ >= 1.0 * I3Units::m) {
            //message does not make sense, we are checking meanFreePath, not an Energy! //fhl
            log_error("Cannot scale energy down! 1 GeV is lower limit\n");
            log_error("Scale Energy turned off");
        }
        else { // scaling energy to 1 m mean free path
            log_info("Scaling Energy/MFP up");
            deltaEnergy_ = ((1.0 * I3Units::m) / meanFreePath_) * deltaEnergy_;
            meanFreePath_ = 1.0 * I3Units::m;
        }
    }

    log_debug("Energy for Delta Electrons is %f (GeV)", deltaEnergy_);
    log_debug("Mean Free Path for Delta Electrons is %f (m)", meanFreePath_);

    /**
    TODO rest
    */
}

void I3MonopolePropagator::DAQ(I3FramePtr frame) {
    log_debug("Entering DAQ I3MonopolePropagator");

    // get generated tree
    I3MCTreeConstPtr mctree = frame->Get<I3MCTreeConstPtr>(inputTreeName_);
    if(!mctree){
      log_fatal("Tree not found in frame, Aborting!");
    }
    // create new tree for propagated monopole
    I3MCTreePtr prop_tree(new I3MCTree(*mctree));
    double beta;
    try {
      const I3MapStringDouble &mpinfo = frame->Get<I3MapStringDouble>(infoName_);
      beta = mpinfo.at("Beta");
    } catch (const std::exception& e) {
      log_fatal("MPInfoDict was not found, Aborting!");
    }

    if (beta <= 0.0 or beta > 0.99995) { //0.99995 is upper limit for relativistic propagator
        log_fatal("Got beta from %s frame, but value is not sane: %g", infoName_.c_str(), beta);
    }

    if (beta > betaThreshold_) {  // relativistic monopole
        I3MonopoleRelativisticUtils::PropagateFastMonopole(frame,
                                                           infoName_,
                                                           mctree,
                                                           prop_tree,
                // params
                                                           stepSize_,
                                                           minlength_,
                                                           maxlength_,
                                                           calcEn_,
                                                           calcDen_,
                                                           speedmin_,
                                                           maxdistfromcenter_,
                                                           checkParticle_,
                                                           profiling_);
    } // end fast

    else {       // non-relativistic monopole

        I3RandomServicePtr random = context_.Get<I3RandomServicePtr>();
        if (!random) {
            log_fatal("Failed to Get Random Service");
        }

        if (std::isnan(
                meanFreePath_)) {   // If the monopole is slow or not is read from the frame, so we have to check this in the DAQ routine.
            log_fatal("The frame seems to contain a slow monopole, but no mean free path is configured.");
        }

        I3MonopoleSlowUtils::PropagateSlowMonopole(frame,
                                                   infoName_,
                                                   mctree,
                                                   prop_tree,
                                                   // params
                                                   random,
                                                   meanFreePath_,
                                                   useCorrectDecay_,
                                                   deltaEnergy_);
    } // end slow


    //Check that there were monopoles
    /*log_info("Propagated %d Monopoles",numMonopoles);
    if(numMonopoles==0)
      log_error("Did not have any monopoles in the tree - should you be calling this module?");
    */ // OBI TODO


    //Remove old tree and replace with new, propagated one
    if (inputTreeName_ == outputTreeName_) {
        frame->Delete(inputTreeName_);
    }
    frame->Put(outputTreeName_, prop_tree);
    PushFrame(frame, "OutBox");

}//End DAQ

void I3MonopolePropagator::Finish() {
}


